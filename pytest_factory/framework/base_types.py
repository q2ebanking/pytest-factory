from __future__ import annotations
import json
from typing import Any, Dict, Union, List, Tuple, AnyStr, Optional, TypeVar, Set

ALLOWED_TYPES = {int, bytes, str, type(None), bool, dict}


def get_kwargs(o: object, pre_not_de: bool = False, allowed_types: Optional[Set[type]] = None) -> Dict[str, Any]:
    allowed_types = allowed_types or ALLOWED_TYPES
    d = o.kwargs if pre_not_de else vars(o)
    d = {k: v if type(v) in allowed_types else str(v)
         for k, v in d.items()
         if v is not o and k not in {'__class__', 'kwargs'}}
    return d


def convert(x):
    if isinstance(x, bytes):
        return f"b'{x.decode()}'"
    elif isinstance(x, str):
        return f'"{x}"'
    elif x is None:
        return 'None'
    elif x is True:
        return 'True'
    elif x is False:
        return 'False'
    else:
        return str(x)


class Message:
    def write(self, just_args: bool = False) -> str:
        d = get_kwargs(self, pre_not_de=True)
        s = ', '.join([f"{k}={convert(v)}" for k, v in d.items()])
        if just_args:
            return s
        return f"{self.__class__.__name__}({s})"

    def serialize(self):
        d = get_kwargs(self, pre_not_de=True)
        return f"{self.__class__}: {json.dumps(d, default=convert)}"

    def __repr__(self):
        return f"<class {self.__class__.__module__}.{self.__class__.__name__}: {get_kwargs(self)}>"


class BaseMockRequest(Message):
    """
    dual-purpose class used to represent:
    - Actual Requests when created from parameters of @actual_request
    - Expected Requests when created from parameters of @mock_server
    (or similar factory)

    these are stored in store fixture, indexed by: test name, factory name(s), then BaseMockRequest
    object
    """

    FACTORY_NAME = 'make_factory'
    FACTORY_PATH = 'pytest_factory.framework.factory'

    def compare(self, other) -> bool:
        """
        we are effectively simulating the third-party endpoint's router here. note that "this" is the request object of
        the test double that MAY match actual. the "other" request object is the actual request generated by the
        component under test
        e.g. "https://www.test.com?id=0&loc=1" should match
        "https://www.test.com?loc=1&id=0"
        """
        raise NotImplementedError


def compare_unknown_types(a, b) -> bool:
    if hasattr(a, 'compare'):
        compare_result = a.compare(b)
    elif hasattr(b, 'compare'):
        compare_result = b.compare(a)
    else:
        compare_result = a == b
    return compare_result


class Factory(dict):
    def __init__(self, req_obj: Union[str, BaseMockRequest], responses: Any):
        super().__init__()
        self.__setitem__(req_obj, responses)

    def __setitem__(self, key, value):
        for _key in self.keys():
            if compare_unknown_types(key, _key):
                return
        super().__setitem__(key, value)

    @property
    def FACTORY_NAME(self):
        return list(self.keys())[0]


class BasePlugin:
    """
    to create a pytest-factory plugin, inherit from this base class and define the following:
    - self.PLUGIN_URL
    - self.get_plugin_responses

    PLUGIN_URL is the url that corresponds to the depended-on-component that this plugin simulates
    """
    # TODO seems unnecessary to make this a class - rework to replace with module
    PLUGIN_URL = None

    def __init__(self):
        if self.PLUGIN_URL is None:
            raise NotImplementedError()

    @staticmethod
    def get_plugin_responses(req_obj: BaseMockRequest) -> Any:
        """
        this method will be called by Store.get_next_response when the system-under-test calls a url matching
        self.PLUGIN_URL. the user-defined plugin should override this method to implement a router that returns
        the plugin-defined test double response
        """
        raise NotImplementedError


ROUTING_TYPE = Dict[
    Union[
        Dict[str, Any],
        BaseMockRequest],
    Any
]
T = TypeVar("T")

MAGIC_TYPE = Optional[Union[List[T], T]]

BASE_RESPONSE_TYPE = Union[Exception, T, AnyStr]
MOCK_RESPONSES_TYPE = List[Tuple[bool, BASE_RESPONSE_TYPE]]
ANY_MOCK_RESPONSE = MAGIC_TYPE[BASE_RESPONSE_TYPE[T, T]]
Exchange = Tuple[Union[BaseMockRequest], BASE_RESPONSE_TYPE]
